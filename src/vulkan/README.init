Vulkan has many objects that need extensive configuration.
The vulkan API itself does not have defaults, but I wanted to provide
those in order to make its usage learning curve not as steep.

After some research it became clear that using C++20's designated initializers
are not suitable in situations where you want to override defaults
that are defined by one or more base classes.

Fortunately, the vulkan API also provides setters in many cases.
This is what we use.

Many objects are members of the Application, for easy access
and RAII destruction, however, it is unfeasible to pass all information
needed for the application, window and vulkan to the constructor
of the Application. Instead, the objects are instantiated in an
order that favour the order in which they need to be destructed
(and the Application is destructed), but the objects themselves
are not initialized during construction.

The exception being the vulkan Instance, which is created during
the construcion of the Application.

Initialization data for all objects is collected, in main, in 'CreateInfo'
structures, that are passed to those functions that need it in order
to finish initialization after construction of the Application object.

Vulkan objects are initialized with sensible defaults upon construction,
which then can be overwritten with setters. For example:

  DebugUtilsMessengerCreateInfoEXT debug_create_info;
  debug_create_info
    setMessageSeverity(
        vk::DebugUtilsMessageSeverityFlagBitsEXT::eWarning |
        vk::DebugUtilsMessageSeverityFlagBitsEXT::eError
    )
    .setMessageType(
        vk::DebugUtilsMessageTypeFlagBitsEXT::eGeneral |
        vk::DebugUtilsMessageTypeFlagBitsEXT::eValidation |
        vk::DebugUtilsMessageTypeFlagBitsEXT::ePerformance)
    ;

Note that here `setMessageSeverity` is only used to show the
cascading of the setters; you should not use it but turn on
or off the appropriate debug channels instead; which automatically
sets the MessageSeverity for you.

Since sometimes a setter is a member function of a base class,
and will return a reference to that base class, you must always
start with the setter(s) of the most derived class first.

For example,

  ApplicationCreateInfo application_create_info;
  application_create_info
    // ApplicationCreateInfo
    .set_number_of_threads(number_of_threads, max_number_of_threads, reserved_threads)
    // vk::ApplicationInfo
    .setPApplicationName("HelloTriangleVulkanApplication")
    .setApplicationVersion(VK_MAKE_VERSION(1, 0, 0))
    ;

where setPApplicationName is a member function of vk::ApplicationInfo
which is a base class of ApplicationCreateInfo and therefore must come
after set_number_of_threads which is a member function of ApplicationCreateInfo.

Of course ApplicationCreateInfo isn't a vulkan object, but it uses setters
as well, so that the setters of vk::ApplicationInfo can seamless be cascased.

Sometimes the constructor of an object requires, besides its own CreateInfo,
another CreateInfo to be passed as parameter because the it needs to modify it.

For example,

  HelloTriangleVulkanApplication application(application_create_info COMMA_CWDEBUG_ONLY(debug_create_info));

where debug_create_info is changed to call a member function of Application
for debug output.

